\documentclass{llncs}
%
\usepackage{makeidx}
\usepackage{listings}
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}
\usepackage{xcolor}
\usepackage[spanish]{babel}
\selectlanguage{spanish}
\usepackage[utf8]{inputenc}
%
\begin{document}
%
\frontmatter
%
\pagestyle{headings}
\addtocmark{Informe TP Funcional}

\title{Informe TP Funcional}
%
\titlerunning{Informe TP Funcional}
%
\author{De León, Lautaro Nahuel}
%
\institute{Universidad Nacional de La Plata}
%
\maketitle

\begin{abstract}
* TODO: Aca iria el abstract del trabajo práctico *
\keywords{Ajedrez, IA, }
\end{abstract}
%
\section{Introducción}
%

La idea del presente trabajo es recrear un juego de ajedrez que permita enfrentamientos contra oponentes humanos y openentes simulados mediante IA. El espíritu de este desarrollo es mantener siempre la simpleza en el diseño y la implementación de manera de tal de poder explicar con relativa fluidez los conceptos involucrados -especialmente en la IA- y que sirva de modelo inicial para futuras iteraciones más sofisticadas.

\subsection{Motivación}
\label{subsec:Motivacion}

La motivación es, principalmente, la suma de dos inquietudes: por un lado, el arrancar un proyecto medianamente serio usando conceptos puros de programación funcional -y Haskell como medio para cumplir estrictamente con dicha premisa-; y por otro lado, el entender de manera clara cómo es la logica de los algoritmos de IA y tratar de aislar esta parte del resto de la aplicación de manera tal de poder generalizarla y usarla potencialmente en otros juegos.
Posteriormente, la idea es publicar el proyecto en un repositorio abierto (por ejemplo, Github) para que la comunidad pueda aprovecharlo, e idealmente, extenderlo con nuevas ideas, correcciones o mejoras.

\subsection{Estructura del trabajo}
\label{subsec:Estructura trabajo}

*TODO: Comentar la estructura del trabajo*

\section{Presentación e interfaz de la aplicación}

Ante todo, es relevante mencionar que se puso más énfasis en la lógica del juego y en la modularización del mismo de manera tal que el desarrollar otra GUI más atractiva sea una tarea relativamente sencilla. En el próxima apartado se detallará la estructura interna de la aplicación.
Ahora sí, respecto a la presente interfaz se puede decir que es textual y la configuración depende de los parámetros pasados al programa, el cual es un comando UNIX. A continuación se presentará una salida típica de la ayuda que brinda esta utilidad:

\begin{lstlisting}[backgroundcolor=\color{cyan}, language=bash, caption=Ayuda de la aplicación label={lst:ayuda_programa}]
> ./chesssimple --help
The Chesssimple program

Chesssimple [COMMAND] ... [OPTIONS]
  Chess game & engine

Common flags:
  -? --help            Display help message
  -V --version         Print version information

Chesssimple hvh [OPTIONS]

     --p1name=ITEM     The player 1's name
     --p1color=ITEM    The player 1's color
     --p2name=ITEM     The player 2's name

Chesssimple [hvc] [OPTIONS]

     --hname=ITEM      The human player's name
     --hcolor=ITEM     The human player's color
  -c --cstrength=INT   The computer player's strength

Chesssimple cvc [OPTIONS]

     --p1strength=INT  The player 1's strength
     --p2strength=INT  The player 2's strength
\end{lstlisting}

La aplicación dispone de 3 modos de juego: \textit{humano vs computadora} -el cual es el modo por defecto-, \textit{humano vs humano} y \textit{computadora vs computadora}. Cada uno de los modos cuenta además con parámetros de configuración específicos para elegir con qué bando jugar -blancas o negras- y, para el caso de los jugadores por CPU, la dificultad o fuerza con la que contará. Vale la pena mencionar que todos estas opciones cuentan también con valores predefinidos.

Una vez iniciada la aplicación, la misma se verá de la siguiente manera:

\begin{lstlisting}[backgroundcolor=\color{cyan}, language=bash, caption=Interfaz principal del programa, label={lst:interfaz_principal}]
Welcome to Simple Chess Game

( -T  _ -B -Q -K -B -N -T )
( -p -p -p -p -p -p -p -p )
(  _  _ -N  _  _  _  _  _ )
(  _  _  _  _  _  _  _  _ )
(  _  _  _ +p  _  _  _  _ )
(  _  _  _  _  _  _  _  _ )
( +p +p +p  _ +p +p +p +p )
( +T +N +B +Q +K +B +N +T )

White moves...
Commands are: exit, which, move, undo
_
\end{lstlisting}

En dónde se encuentra el tablero y las pieces representadas por una matriz de caracteres, donde el significado para cada una de ellas es:
\newline

\setlength{\tabcolsep}{20pt}
\begin{tabular}{ l | c }
  Caracter & Significado \\
  \hline
  T & Torre \\
  N & Caballo \\
  B & Alfil \\
  Q & Dama \\
  K & Rey \\
  p & Peón \\
\end{tabular}
\newline
\newline

Y los colores se representan como:
\newline

\setlength{\tabcolsep}{20pt}
\begin{tabular}{ l | c }
  Caracter & Significado \\
  \hline
  + & Blanco \\
  - & Negro \\
\end{tabular}
\newline
\newline

En cuanto a la notación posicional se puede mencionar que es totalmente numérica, es decir, cada casillero o escaque se identifica por el número de fila y de columna entre el 1 y el 8, siendo 11 la casilla superior izquierda y 88 la casilla inferior derecha, con lo cual, la numeración incrementa hacia la derecha -para el caso de las columnas- y hacia abajo -para el caso de las filas-. A modo de ejmplo, en la posicional inicial de ajedrez (desde la perspectiva del tablero en \ref{lst:interfaz_principal}), peón blanco movió desde 74 a 54 y el caballo negro movió desde 12 a 33.

La mecánica del juego consiste, para un jugador humano, en introducir comandos. Los disponibles actualmente son:
\newline

\begin{labeling}{which}
  \item [move] Este es claramente el comando principal. Permite indicar una posición de partida y una de destino utilizando la notación previamente comentada. Por ejemplo, \textit{move 74 54} mueve el peón blanco de la columna 4 dos casilleros hacia adelante.

    Si la posición es inválida (porque está mal escrita, fuera de los límites del tablero, o el casillero no tiene una ficha correspondiente al bando propio), el comando se cancela.
  \item[which] Dada la posición de una pieza del bando propio, lista todas las posiciones a las cuales podría moverse. Similar al \textit{move}, no dará ningún resultado si la posición es inválida. Además tampoco dará resultados si la posición está en jaque y la pieza candidata a mover no puede contrarrestar esa situación. Por ejemplo, para el alfin blanco ubicado en 83 en la figura \ref{lst:interfaz_principal}, los movimientos disponibles arrojados por el comando son: 74, 65, 56, 47, 38
  \item[undo] Deshace un turno completo, es decir, el turno del rival y el propio. Por ejemplo, para la situación planteada en la figura \ref{lst:interfaz_principal}, ejecutar \textit{undo} llevaría el juego a la posición inicial nuevamente.
  \item[exit] Sale del programa.
\end{labeling}

%
% ---- Bibliography ----
%
\begin{thebibliography}{}
  \bibitem[1]{whyfunctional}
  John Hughes - "Why functional programming matters"
  \bibitem[2]{introfunctional}
  Richard Bird, Philip Wadler - "Introduction to Functional Programming"
\end{thebibliography}

\end{document}
